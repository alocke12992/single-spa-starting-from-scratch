'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _defaultOpts;

exports.default = singleSpaReact;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* We don't import parcel.component.js from this file intentionally. See comment
 * in that file for why
 */

// React context that gives any react component the single-spa props
var SingleSpaContext = exports.SingleSpaContext = null;

var defaultOpts = (_defaultOpts = {
  // required opts
  React: null,
  ReactDOM: null,
  rootComponent: null,
  loadRootComponent: null,
  domElementGetter: null,
  suppressComponentDidCatchWarning: false

}, _defineProperty(_defaultOpts, 'domElementGetter', null), _defineProperty(_defaultOpts, 'parcelCanUpdate', true), _defaultOpts);

function singleSpaReact(userOpts) {
  if ((typeof userOpts === 'undefined' ? 'undefined' : _typeof(userOpts)) !== 'object') {
    throw new Error('single-spa-react requires a configuration object');
  }

  var opts = _extends({}, defaultOpts, userOpts);

  if (!opts.React) {
    throw new Error('single-spa-react must be passed opts.React');
  }

  if (!opts.ReactDOM) {
    throw new Error('single-spa-react must be passed opts.ReactDOM');
  }

  if (!opts.rootComponent && !opts.loadRootComponent) {
    throw new Error('single-spa-react must be passed opts.rootComponent or opts.loadRootComponent');
  }

  if (!SingleSpaContext && opts.React.createContext) {
    exports.SingleSpaContext = SingleSpaContext = opts.React.createContext();
  }

  var lifecycles = {
    bootstrap: bootstrap.bind(null, opts),
    mount: mount.bind(null, opts),
    unmount: unmount.bind(null, opts)
  };

  if (opts.parcelCanUpdate) {
    lifecycles.update = update.bind(null, opts);
  }

  return lifecycles;
}

function bootstrap(opts, props) {
  if (opts.rootComponent) {
    // This is a class or stateless function component
    return Promise.resolve();
  } else {
    // They passed a promise that resolves with the react component. Wait for it to resolve before mounting
    return opts.loadRootComponent().then(function (resolvedComponent) {
      opts.rootComponent = resolvedComponent;
    });
  }
}

function mount(opts, props) {
  return new Promise(function (resolve, reject) {

    if (!opts.rootComponent.prototype.componentDidCatch && !opts.suppressComponentDidCatchWarning && atLeastReact16(opts.React)) {
      console.warn('single-spa-react: ' + (props.name || props.appName || props.childAppName) + '\'s rootComponent should implement componentDidCatch to avoid accidentally unmounting the entire single-spa application.');
    }

    var domElementGetter = chooseDomElementGetter(opts, props);

    if (!domElementGetter) {
      throw new Error('Cannot mount react application \'' + (props.appName || props.name) + '\' without a domElementGetter provided in either opts or props');
    }

    var whenFinished = function whenFinished() {
      resolve(this);
    };

    var rootComponentElement = opts.React.createElement(opts.rootComponent, props);
    var elementToRender = SingleSpaContext ? opts.React.createElement(SingleSpaContext.Provider, { value: props }, rootComponentElement) : rootComponentElement;
    var domElement = getRootDomEl(domElementGetter);
    var renderedComponent = opts.ReactDOM.render(elementToRender, domElement, whenFinished);
    opts.domElement = domElement;
  });
}

function unmount(opts, props) {
  return Promise.resolve().then(function () {
    opts.ReactDOM.unmountComponentAtNode(opts.domElement);
  });
}

function update(opts, props) {
  return new Promise(function (resolve, reject) {
    var whenFinished = function whenFinished() {
      resolve(this);
    };

    var rootComponentElement = opts.React.createElement(opts.rootComponent, props);
    var elementToRender = SingleSpaContext ? opts.React.createElement(SingleSpaContext.Provider, { value: props }, rootComponentElement) : rootComponentElement;
    var renderedComponent = opts.ReactDOM.render(elementToRender, opts.domElement, whenFinished);
  });
}

function getRootDomEl(domElementGetter) {
  var el = domElementGetter();
  if (!el) {
    throw new Error('single-spa-react: domElementGetter function did not return a valid dom element');
  }

  return el;
}

function atLeastReact16(React) {
  if (React && typeof React.version === 'string' && React.version.indexOf('.') >= 0) {
    var majorVersionString = React.version.slice(0, React.version.indexOf('.'));
    try {
      return Number(majorVersionString) >= 16;
    } catch (err) {
      return false;
    }
  } else {
    return false;
  }
}

function chooseDomElementGetter(opts, props) {
  props = props && props.customProps ? props.customProps : props;
  if (props.domElement) {
    return function () {
      return props.domElement;
    };
  } else if (props.domElementGetter) {
    return props.domElementGetter;
  } else {
    return opts.domElementGetter;
  }
}

//# sourceMappingURL=single-spa-react.js.map